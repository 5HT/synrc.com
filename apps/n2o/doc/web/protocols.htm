<!DOCTYPE html>
<html >
<head>

  <link rel=stylesheet type="text/css" href="http://synrc.com/synrc.css">
  <meta name="Author" content="5HT">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta property="og:image" content="images/s_64.png"/>
  <meta http-equiv="X-UA-Compatible" content="IE=IE10,chrome=1" />
  <!--link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'-->
  <title>N2O WebSocket Protocol
</title>
</head>
<body >
<!--HEVEA command line is: hevea protocols.tex -o protocols.htm -->
<!--CUT STYLE article--><!--HTMLHEAD-->

<div class="nonselectedwrapper white" style="padding: 10px 0px 10px 0px;margin: 0px 0px 10px 0px;">
    <a href="//synrc.com/">
    <img style="flat:left; margin-left: 55px; margin-top: 5px; margin-bottom:-5px;" src="http://synrc.com/images/synrc.png" border="0"></a>
    <div align=right style="margin: -50px 50px 0px 0px;">
        <script language="JavaScript">

        var args = (window.location).toString().split('/');
        var page_name = args[args.length-1];
        var menu = {'http://synrc.com/index.htm':    'Home',
                    'http://synrc.com/research.htm': 'Showcase',
                    'http://synrc.com/apps/':   'Apps',
                    'http://synrc.com/feedback.htm': 'Contacts',
                    'http://spawnproc.com':   '<b>Spawnproc</b>', };

        Object.keys(menu).forEach(function (key) {
            if (page_name == key) { document.write('<div class="menu" style="font-weight: bold;">'+menu[key]+'</div>'); }
            else { document.write('<a class="menu" href="'+key+'">'+menu[key]+'</a>'); }
        });

        </script>
    </div>
</div>

<hr size="1">

<!--ENDHTML-->
<!--CUT DEF section 1 --><div class="nonselectedwrapper">
<div class="article">
<div class="toc">
<!--TOC section id="sec1" TOC-->
<h2 id="sec1" class="section">TOC</h2><!--SEC END -->
<!--TOC paragraph id="sec2" -->
<!--SEC END --><p>
<a href="http://synrc.com/apps/n2o/doc/web">1. Framework</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/setup.htm">2. Setup</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/processes.htm">3. Processes</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/endpoints.htm">4. Endpoints</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/handlers.htm">5. Handlers</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/protocols.htm">6. Protocols</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/macros.htm">7. JavaScript</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/api.htm">8. API</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/elements.htm">9. Elements</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/actions.htm">10. Actions</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/utf8.htm">11. UTF-8</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/packages.htm">12. Packages</a> <br>

<a href="http://synrc.com/apps/n2o/doc/web/persistence.htm">13. Persistence</a> <br>
</p><p><a href="http://synrc.com/apps/n2o/doc/book.pdf">Download PDF</a> <br>

</p></div>

<div class="articlecol">

<!--TOC section id="sec3" Protocols-->
<h2 id="sec3" class="section">Protocols</h2><!--SEC END --><p>
N2O is more that just web framework or even application server.
It also has protocol specification that covers broad range of application domains.
In this chapter we go deep inside network capabilities of N2O communications.
N2O protocol also has an ASN.1 formal description, however here we will speak on it freely.
Here is the landscape of N2O protocols stack.</p><p>

<img src="http://synrc.com/apps/n2o/doc/images/n2o-proto.png" style="margin-left: -20px;margin-botton: 30px; padding:20 20 20 20px;"><br>

Picture. <span style="font-weight:bold">Protocols Stack</span><br>
<br>



You may find it similar to XML-based XMPP, binary COM/CORBA,
JSON-based WAMP, Apache Camel or Microsoft WCF communication foundations.
We took best from all and put into one protocols stack for web,
social and enterprise domains providing stable and mature implementation for Erlang
in a form of N2O application server.</p><!--TOC subsection id="sec4" Cross Language Compatibility-->
<h3 id="sec4" class="subsection">Cross Language Compatibility</h3><!--SEC END --><p>
N2O application server implemented to support N2O protocol protocol defenition
in Erlang which is widely used in enterprise applications.
Experimental implementation in Haskell <span style="font-weight:bold">n2o.hs</span> exists
which supports only core <span style="font-weight:bold">heart</span> protocol along with <span style="font-weight:bold">bert</span> formatter.
We will show you how N2O clients are compatible across
different server implementations in different languages.</p><!--TOC subsection id="sec5" Web Protocols: <span style="font-weight:bold">nitro</span>, <span style="font-weight:bold">spa</span>, <span style="font-weight:bold">bin</span>-->
<h3 id="sec5" class="subsection">Web Protocols: <span style="font-weight:bold">nitro</span>, <span style="font-weight:bold">spa</span>, <span style="font-weight:bold">bin</span></h3><!--SEC END --><p>
N2O protocols stack provides definition for several unoverlapped protocol layers.
N2O application server implementaion of N2O protocol specification supports
four protocol layers from this stack for WebSocket and IoT applications: <span style="font-weight:bold">heart</span>, <span style="font-weight:bold">nitro</span>, <span style="font-weight:bold">spa</span> and <span style="font-weight:bold">bin</span> protocols.
HEART protocol is designed for reliable managed connections and stream channel initialization.
The domain of NITRO protocol is HTML5 client/server interoperability, HTML events and JavaScript delivery.
SPA protocol dedicated for games and static page applications that involves no HTML,
such as SVG based games or non-gui IoT applications.
And finally binary file transfer protocol for images and gigabyte file uploads and downloads.
All these protocols transfers coexist in the same multi-channel stream.</p><!--TOC subsection id="sec6" Social Protocols: <span style="font-weight:bold">roster</span>, <span style="font-weight:bold">muc</span>, <span style="font-weight:bold">search</span>-->
<h3 id="sec6" class="subsection">Social Protocols: <span style="font-weight:bold">roster</span>, <span style="font-weight:bold">muc</span>, <span style="font-weight:bold">search</span></h3><!--SEC END --><p>
For social connectivity one may need to use <span style="font-weight:bold">synrc/roster</span> instant messaging server
that supports <span style="font-weight:bold">roster</span> protocol with variation
for enabling public rooms <span style="font-weight:bold">muc</span> or full-text <span style="font-weight:bold">search</span> facilities.</p><!--TOC subsection id="sec7" Enterprise Protocols: <span style="font-weight:bold">bpe</span>, <span style="font-weight:bold">mq</span>, <span style="font-weight:bold">rest</span>-->
<h3 id="sec7" class="subsection">Enterprise Protocols: <span style="font-weight:bold">bpe</span>, <span style="font-weight:bold">mq</span>, <span style="font-weight:bold">rest</span></h3><!--SEC END --><p>
There is no single system shipped to support all of N2O protocols but it
could exist theoretically. For other protocols implementation you may refer
to other products like <span style="font-weight:bold">spawnproc/bpe</span>, <span style="font-weight:bold">synrc/rest</span> or <span style="font-weight:bold">synrc/mq</span>.</p><!--TOC subsection id="sec8" Channel Termination Formatters-->
<h3 id="sec8" class="subsection">Channel Termination Formatters</h3><!--SEC END --><p>
N2O protocol is formatter agnostic and it doesn’t strict you
to use a particular encoder/decoder.
Application developers could choose their own formatter per protocol.</p><div class="lstlisting">    1. BERT : {io,"fire();",1}
    2. WAMP : [io,"fire();",1]
    3. JSON : {name:io,eval:"fire();",data:1}
    4. TEXT : IO \xFF fire(); \xFF 1\n
    5. XML  : &lt;io&gt;&lt;eval&gt;fire();&lt;/eval&gt;&lt;data&gt;1&lt;/data&gt;&lt;/io&gt;</div><p>E.g. N2O uses TEXT formatting for “PING” and “N2O,” protocol messages,
across versions N2O used to have IO message formatted with JSON and BERT both.
All other protocol messages were BERT from origin.
Make sure formatters set for client and server is compatible.</p><div class="lstlisting">    &gt; application:set_env(n2o,formatter,bert).</div><p>Note that you may include to support more that one protocol on the client.
At server side you can change formatter on the fly without breaking
the channel stream. Each message during data stream could be formatted
using only one protocol at a time. If you want to pass each message
through more that one formatter you should write an echo protocol.</p><div class="lstlisting">    &lt;script src='/n2o/protocols/bert.js'&gt;&lt;/script&gt;
    &lt;script src='/n2o/protocols/client.js'&gt;&lt;/script&gt;
    &lt;script&gt;protos = [ $bert, $client ]; N2O_start();&lt;/script&gt;</div><!--TOC subsection id="sec9" Protocol Loop-->
<h3 id="sec9" class="subsection">Protocol Loop</h3><!--SEC END --><p>
After message arrives to endpoint and handlers chain is being initializes,
message then comes to protocol stack. N2O selects appropropriative protocol
module and handle the message. After than message is being formatted and
replied back to stream channel. Note that protocol loop is applicable
only to WebSocket stream channel endpoint.</p><p>

<img src="http://synrc.com/apps/n2o/doc/images/n2o_protocols.png" style="margin-left: -20px;margin-botton: 30px; padding:20 20 20 20px;"><br>

Picture. <span style="font-weight:bold">Messaging Pipeline</span><br>
<br>



Here is pseudocode how message travels for each protocol until some
of them handle the message. Note tnat this logic is subject to change.</p><div class="center">Listing 1: Top-level protocol loop in n2o_proto</div><p><br>
</p><div class="lstlisting">    reply(M,R,S)              -&gt; {reply,M,R,S}.
    nop(R,S)                  -&gt; {reply,&lt;&lt;&gt;&gt;,R,S}.
    push(_,R,S,[],_Acc)       -&gt; nop(R,S);
    push(M,R,S,[H|T],Acc)     -&gt;
        case H:info(M,R,S) of
              {unknown,_,_,_} -&gt; push(M,R,S,T,Acc);
             {reply,M1,R1,S1} -&gt; reply(M1,R1,S1);
                            A -&gt; push(M,R,S,T,[A|Acc]) end.</div><!--TOC subsection id="sec10" Enabling Protocols-->
<h3 id="sec10" class="subsection">Enabling Protocols</h3><!--SEC END --><p>
You may set up protocol from sys.config file,
enabling or disabling some of them on the fly.</p><div class="lstlisting">    protocols() -&gt;
       wf:config(n2o,protocols,[ n2o_heart,
                                 n2o_nitrogen,
                                 n2o_client,
                                 n2o_file  ]).</div><p>For example in Skyline (DSL) application you use only <span style="font-weight:bold">nitro</span> protocol:</p><div class="lstlisting">    &gt; wf:config(n2o,protocols).
    [n2o_heart,n2o_nitrogen]</div><p>And in Games (SPA) application you need only <span style="font-weight:bold">spa</span> protocol:</p><div class="lstlisting">    &gt; wf:config(n2o,protocols).
    [n2o_heart,n2o_client]</div>
<!--TOC subsection id="sec11" Heartbeat-->
<h3 id="sec11" class="subsection">Heartbeat</h3><!--SEC END --><p>N2O also provides basic Heartbeat protocol that can be formatted at your whim.
Heartbeat protocol is essential WebSocket application level protocol for
PING and N2O initialization. It pings every 4-5 seconds from client-side to server
thus allowing to determine client online presence. On reconnection or initial connect
client sends N2O init marker telling to server to reinitialize the context.</p><div class="lstlisting">    ws.send('PING');
    ws.send('N2O,');</div><p>You can try manually send these messages in web console to see whats happening,
also you can enable logging the heartbeat protocol by including its module in log_modules:</p><div class="lstlisting">    log_modules() -&gt; [n2o_heart].</div><p>Heartbeat protocol PING request returns empty message NOP binary response;
N2O messages returns JSON with EVAL fields of rendered actions.</p>
<!--TOC subsection id="sec12" Nitrogen Compatibility Layer-->
<h3 id="sec12" class="subsection">Nitrogen Compatibility Layer</h3><!--SEC END --><p>NITRO protocol consist of three protocol messages: <span style="font-weight:bold">pickle</span>, <span style="font-weight:bold">flush</span> and <span style="font-weight:bold">direct</span>.
Pickled messages are used if you send messages over unencrypted
channel and want to hide the content of the message,
that was generated on server. You can use BASE64 pickling mechanisms
with optional AES/RIPEMD160 encrypting.</p><div class="lstlisting">    ws.send(enc(tuple(atom('pickle'),
        binary('ddtake'),
        binary('g2gCaAVkAAJldmQABWluZGV4ZAAEdGFrZWsABH'+
                Rha2VkAAVldmVudGgDYgAABXViAAQKXmIAC3cK'),
        [tuple(atom('ddtake'),'0')])));</div><p>Where Base64 represents the N2O EVENT:</p><div class="lstlisting">    #ev{module=index,msg=take,trigger="take",name=event}</div><p>This is Nitrogen-based messaging model. Nitrogen WebSocket processes receive also
flush and delivery protocol messages, but originated from server. These are internal Nitrogen
protocol messages. This request will return JSON with EVAL field only.</p>
<!--TOC subsection id="sec13" Client/Server-->
<h3 id="sec13" class="subsection">Client/Server</h3><!--SEC END --><p>Client messages usually originated at client and represent the Client API Requests:</p><div class="lstlisting">    ws.send(enc(tuple(
        atom('client'),
        tuple(atom('join_game'),1000001))));</div><p>Server messages are usually being sent to client originated on the
server by sending <span style="font-weight:bold">info</span> notifications directly to Web Socket process:</p><div class="lstlisting">    &gt; WebSocketPid ! {server, Message}</div><p>You can obtain this Pid like here:</p><div class="lstlisting">    event(init) -&gt; wf:info(?MODULE, "Web Socket Pid: ~p",[self()]);</div><p>You can also send server messages from client relays and vice versa.
But it is up to your application and client/server handlers how to handle these messages.</p><div class="lstlisting">    ws.send(enc(tuple(
        atom('server'),
        tuple(atom('attach'),1000001))));</div><p>NOTE: client/server request may return JSON with EVAL and DATA fields.</p><!--TOC subsection id="sec14" JSON enveloped EVAL and DATA-->
<h3 id="sec14" class="subsection">JSON enveloped EVAL and DATA</h3><!--SEC END --><p>Each message from Web Socket channel to Client is encoded as JSON object.
<a href="https://github.com/5HT/n2o/blob/master/priv/n2o.js">N2O.js</a>
is used to decode WebSocket binary messages from JSON container.</p><div class="lstlisting">    { "eval": "ws.send("Send Back This String");",
      "data": [ 131,104,2,100,0,7,109,101,115,115,
                97,103,101,107,0,5,72,101,108,108,111 ] }</div><p>EVAL values are evaluated immediately and DATA values are passed
to handle_web_socket(data) function if it exists.</p><div class="lstlisting">    function handle_web_socket(body) { console.log(body); }</div><!--TOC subsection id="sec15" JSON enveloped BERT-->
<h3 id="sec15" class="subsection">JSON enveloped BERT</h3><!--SEC END --><p>Usually in DATA come BERT messages (Binary Erlang Term Format).
<a href="https://github.com/5HT/n2o/blob/master/priv/bert.js">BERT.js</a>
is used to decode application protocol message.</p><div class="lstlisting">    function handle_web_socket(body) {
        console.log(String(dec(body))); }</div><div class="lstlisting">    E&gt; Received: {message,"Hello"}</div>
<!--TOC subsection id="sec16" Binary-->
<h3 id="sec16" class="subsection">Binary</h3><!--SEC END --><p>When you need raw binary Blob on client-side,
for images or other raw data, you can ask server like this:</p><div class="lstlisting">    ws.send(enc(tuple(
        atom('bin'),
        binary('API Request'));</div><p>And handle also in binary clause:</p><div class="lstlisting">    event({binary,Message}) -&gt;
        wf:info(?MODULE, "This API will return Raw Binary", []),
        &lt;&lt;84,0,0,0,108&gt;&gt;;</div><p>NOTE: if event returns not the binary, client will receive BERT encoded message.</p><!--TOC subsection id="sec17" BERT-->
<h3 id="sec17" class="subsection">BERT</h3><!--SEC END --><p>Erlang RPC protocol interconnection with JavaScript nodes should be transferred as BERT answers.</p><div class="lstlisting">    function handle_web_socket(body) {
        console.log(String(dec(body))); }</div><!--TOC subsection id="sec18" RAW Binary-->
<h3 id="sec18" class="subsection">RAW Binary</h3><!--SEC END --><p>Raw images for fastest possible speed should be transferred as binary answers.</p><div class="lstlisting">    function handle_web_socket_blob(body) { }</div><div class="lstlisting">    E&gt; Unknown Raw Binary Received: [72,101,108,108,111]</div><p>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'synrc'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</p></div>
</div>
</div><div class="clear"> </div><!--CUT END -->
<!--HTMLFOOT-->

<div class="nonselectedwrapper">
<div class="verywidecol">

    <div style="width:100%;height:300px;float:left;font-size:16pt;" align=center>
    	<hr size=1>
    	<br><br><br>
        <a href="//synrc.com/news/index.htm">Events</a> |
    	<a href="//synrc.com/privacy.htm">Privacy Policy</a> |
        <a href="//synrc.com/feedback.htm">Feedback</a> |
        <a href="//synrc.com/brandbook.htm">Brandbook</a><br>
    	Copyright &copy; 2005&ndash;2015 <a href="//synrc.com/index.htm"> Synrc Research Center s.r.o.</a>
    </div>

</div>
</div>

<div class="clear"></div>

<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-29227518-1']);
      _gaq.push(['_trackPageview']);
      
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();
                      
                      </script>

<script type="text/javascript" src="http://synrc.com/hi.js"></script>
<!--ENDHTML-->
</body>
</html>
